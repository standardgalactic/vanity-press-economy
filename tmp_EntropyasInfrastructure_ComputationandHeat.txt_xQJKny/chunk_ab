Σ
1
∪
Σ
2
,
D
1
⊔
D
2
,
φ
1
⊎
φ
2
)
M_1 \otimes M_2 = (F_1 \uplus F_2, \Sigma_1 \cup \Sigma_2, D_1 \sqcup D_2, \varphi_1 \uplus \varphi_2)
M
1
​
⊗
M
2
​
=
(
F
1
​
⊎
F
2
​
,
Σ
1
​
∪
Σ
2
​
,
D
1
​
⊔
D
2
​
,
φ
1
​
⊎
φ
2
​
)
.
\section{Semantic Merge Operators via Homotopy Colimits}
\label{app:merge-operators}
Let
D
:
I
→
S
e
m
D: I \to \mathbf{Sem}
D
:
I
→
Sem
be a diagram of semantic modules in
S
e
m
\mathbf{Sem}
Sem
.
The semantic merge
M
e
r
g
e
(
{
M
i
}
)
=
h
o
c
o
l
i
m
i
∈
I
M
i
\mathsf{Merge}(\{M_i\}) = \mathrm{hocolim}_{i \in I} M_i
Merge
({
M
i
​
})
=
hocolim
i
∈
I
​
M
i
​
.
Properties:
Entropy Non-Increase:
S
(
M
e
r
g
e
(
{
M
i
}
)
)
≤
sup
⁡
i
∈
I
S
(
M
i
)
S(\mathsf{Merge}(\{M_i\})) \le \sup_{i \in I} S(M_i)
S
(
Merge
({
M
i
​
}))
≤
sup
i
∈
I
​
S
(
M
i
​
)
Expanded proof: The homotopy colimit constructs a cone over the diagram where paths (homotopies) minimize entropy inflation by aligning branches coherently, ensuring the supremum bound via the universal property of colimits.
\section{CLIO as a Recursive Inference Functor}
\label{app:clio-functor}
Define CLIO as:
C
L
I
O
:
S
e
m
→
S
e
m
\mathsf{CLIO}: \mathbf{Sem} \to \mathbf{Sem}
CLIO
:
Sem
→
Sem
C
(
M
)
=
∫
X
κ
(
Φ
M
(
x
)
,
v
⃗
M
(
x
)
,
S
M
(
x
)
)
d
μ
(
x
)
\mathcal{C}(M) = \int_{\mathcal{X}} \kappa(\Phi_M(x), \vec{v}_M(x), S_M(x)) \, d\mu(x)
C
(
M
)
=
∫
X
​
κ
(
Φ
M
​
(
x
)
,
v
M
​
(
x
)
,
S
M
​
(
x
))
d
μ
(
x
)
Φ
,
v
⃗
,
S
\Phi, \vec{v}, S
Φ
,
v
,
S
are RSVP scalar, vector, and entropy fields mapped from
M
M
M
.
κ
\kappa
κ
is a kernel measuring field alignment with semantic objectives.
CLIO iteration:
M
t
+
1
=
M
e
r
g
e
(
{
O
p
t
i
m
i
z
e
ℓ
(
M
t
)
}
ℓ
∈
L
)
M_{t+1} = \mathsf{Merge}(\{ \mathsf{Optimize}_\ell(M_t) \}_{\ell \in L})
M
t
+
1
​
=
Merge
({
Optimize
ℓ
​
(
M
t
​
)
}
ℓ
∈
L
​
)
Expansion: This recursive structure enables in-situ optimization, where each iteration refines the module based on local objectives, converging to entropy-minimal configurations through merge operations.
\section{Thermodynamic Model of Compute-for-Heat}
\label{app:thermo-model}
Let
Q
Q
Q
be the total heat generated by a computational device over time
τ
\tau
τ
:
Q
=
τ
⋅
P
comp
Q = \tau \cdot P_{\text{comp}}
Q
=
τ
⋅
P
comp
​
By Landauer's bound:
Q
≥
k
B
T
ln
⁡
2
⋅
N
ops
Q \ge k_B T \ln 2 \cdot N_{\text{ops}}
Q
≥
k
B
​
T
ln
2
⋅
N
ops
​
\subsection{Useful Computation Constraint}
We define the utility functional:
U
=
∑
j
V
a
l
u
e
(
T
j
)
Q
\mathcal{U} = \frac{\sum_{j} \mathrm{Value}(T_j)}{Q}
U
=
Q
∑
j
​
Value
(
T
j
​
)
​
We require:
U
≥
U
min
\mathcal{U} \ge \mathcal{U}_{\text{min}}
U
≥
U
min
​
Expanded derivation: The value function
V
a
l
u
e
(
T
j
)
\mathrm{Value}(T_j)
Value
(
T
j
​
)
quantifies epistemic contributions of tasks
T
j
T_j
T
j
​
, ensuring heat expenditure correlates with utility gains.
\section{RSVP Field Coupling}
\label{app:rsvp-coupling}
Let
E
\mathcal{E}
E
be the total environmental energy demand for thermoregulation, and
Q
comp
Q_{\text{comp}}
Q
comp
​
the heat provided by computation.
The coupling equation in RSVP form:
∂
S
∂
t
+
∇
⋅
(
v
⃗
S
)
=
σ
comp
−
σ
loss
\frac{\partial S}{\partial t} + \nabla \cdot (\vec{v} S) = \sigma_{\text{comp}} - \sigma_{\text{loss}}
∂
t
∂
S
​
+
∇
⋅
(
v
S
)
=
σ
comp
​
−
σ
loss
​
σ
comp
\sigma_{\text{comp}}
σ
comp
​
is the entropy injection from computation.
σ
loss
\sigma_{\text{loss}}
σ
loss
​
models environmental dissipation.
The optimization problem:
max
⁡
M
∈
S
e
m
U
(
M
)
s.t.
Q
comp
≥
E
\max_{M \in \mathbf{Sem}} \ \mathcal{U}(M) \quad \text{s.t.} \quad Q_{\text{comp}} \ge \mathcal{E}
max
M
∈
Sem
​
U
(
M
)
s.t.
Q
comp
​
≥
E
Expansion: This Lagrangian formulation balances maximization of utility with constraint satisfaction, solvable via gradient methods in the RSVP field space.
\section{Appendix A: Monoidal Functor Structure of PoUWH}
\label{app:monoidal-pouwh}
\subsection{Categories in Play}
P
\mathcal{P}
P
— Category of Physical Devices
Objects: Physical computational-thermal nodes (GPUs, cymatic yogurt computers, lunar simulators, etc.).
Morphisms: Physical reconfigurations and task assignments.
Monoidal product:
⊗
P
=
\otimes_{\mathcal{P}} =
⊗
P
​
=
parallel physical operation.
I
\mathcal{I}
I
— Category of Infrastructure States
Objects: System-wide states
(
Θ
,
Σ
)
(\Theta, \Sigma)
(
Θ
,
Σ
)
, where
Θ
\Theta
Θ
= thermal distribution vector,
Σ
\Sigma
Σ
= semantic knowledge state.
Morphisms: Valid transitions in thermal and semantic state.
Monoidal product:
⊗
I
=
\otimes_{\mathcal{I}} =
⊗
I
​
=
parallel state transitions.
\subsection{Functor Definition}
The PoUWH functor:
F
P
o
U
W
H
:
P
→
I
F_{\mathrm{PoUWH}}: \mathcal{P} \to \mathcal{I}
F
PoUWH
​
:
P
→
I
On objects:
F
P
o
U
W
H
(
d
)
=
(
Θ
d
,
Σ
d
)
F_{\mathrm{PoUWH}}(d) = (\Theta_d, \Sigma_d)
F
PoUWH
​
(
d
)
=
(
Θ
d
​
,
Σ
d
​
)
On morphisms:
F
P
o
U
W
H
(
m
:
d
→
d
′
)
=
(
τ
m
,
σ
m
)
F_{\mathrm{PoUWH}}(m: d \to d') = (\tau_m, \sigma_m)
F
PoUWH
​
(
m
:
d
→
d
′
)
=
(
τ
m
​
,
σ
m
​
)
\subsection{Monoidal Structure}
Tensor Preservation: For devices
d
1
,
d
2
d_1, d_2
d
1
​
,
d
2
​
:
F
P
o
U
W
H
(
d
1
⊗
P
d
2
)
=
F
P
o
U
W
H
(
d
1
)
⊗
I
F
P
o
U
W
H
(
d
2
)
F_{\mathrm{PoUWH}}(d_1 \otimes_{\mathcal{P}} d_2) = F_{\mathrm{PoUWH}}(d_1) \otimes_{\mathcal{I}} F_{\mathrm{PoUWH}}(d_2)
F
PoUWH
​
(
d
1
​
⊗
P
​
d
2
​
)
=
F
PoUWH
​
(
d
1
​
)
⊗
I
​
F
PoUWH
​
(
d
2
​
)
(
Θ
d
1
∥
d
2
,
Σ
d
1
∥
d
2
)
=
(
Θ
d
1
⊕
Θ
d
2
,
Σ
d
1
⊔
Σ
d
2
)
(\Theta_{d_1 \parallel d_2}, \Sigma_{d_1 \parallel d_2}) = (\Theta_{d_1} \oplus \Theta_{d_2},\; \Sigma_{d_1} \sqcup \Sigma_{d_2})
(
Θ
d
1
​
∥
d
2
​
​
,
Σ
d
1
​
∥
d
2
​
​
)
=
(
Θ
d
1
​
​
⊕
Θ
d
2
​
​
,
Σ
d
1
​
​
⊔
Σ
d
2
​
​
)
Unit Preservation:
F
P
o
U
W
H
(
I
P
)
=
I
I
F_{\mathrm{PoUWH}}(I_{\mathcal{P}}) = I_{\mathcal{I}}
F
PoUWH
​
(
I
P
​
)
=
I
I
​
.
\subsection{Functoriality}
F
P
o
U
W
H
(
n
∘
m
)
=
F
P
o
U
W
H
(
n
)
∘
F
P
o
U
W
H
(
m
)
F_{\mathrm{PoUWH}}(n \circ m) = F_{\mathrm{PoUWH}}(n) \circ F_{\mathrm{PoUWH}}(m)
F
PoUWH
​
(
n
∘
m
)
=
F
PoUWH
​
(
n
)
∘
F
PoUWH
​
(
m
)
\subsection{No Wasted Computation Theorem}
Theorem: If
P
\mathcal{P}
P
is equipped with an efficiency filter rejecting morphisms with
η
(
m
)
<
η
min
⁡
\eta(m) < \eta_{\min}
η
(
m
)
<
η
m
i
n
​
, then
F
P
o
U
W
H
F_{\mathrm{PoUWH}}
F
